# Next.js 변환 API 설계 및 구현 계획

## 📋 현재 상황 분석

### **기존 PyQt5 구조**
- **실시간 데이터**: 4개 타이머 기반 폴링 (계좌조회 2초, TR결과 0.05초 등)
- **데이터 구조**: pandas DataFrame (realtime_watchlist_df, account_info_df)
- **주요 기능**: RSI/MACD 매매 시그널, 실시간 가격 업데이트, 계좌 정보 표시

### **Next.js 웹앱 현황**
- **기술스택**: Next.js 15.5.2, TypeScript, shadcn/ui, Tailwind CSS
- **현재상태**: 정적 UI 구현 완료 (매수/매도 조건 설정, 계좌 정보, 워치리스트)
- **필요사항**: 백엔드 API 연동, 실시간 데이터 통신

## 🏗️ API 아키텍처 설계

### **1. REST API 엔드포인트**

#### **📊 계좌 관리 API**
```typescript
// GET /api/account/balance - 계좌 잔고 조회
interface AccountBalance {
  total_value: number;
  holdings: Array<{
    stock_code: string;
    stock_name: string;
    quantity: number;
    avg_price: number;
    current_price: number;
    profit_rate: number;
    unrealized_pnl: number;
  }>;
}

// GET /api/account/summary - 계좌 요약
interface AccountSummary {
  account_number: string;
  total_asset: number;
  available_cash: number;
  total_profit_loss: number;
  daily_pnl: number;
}
```

#### **📈 매매 조건 API**
```typescript
// GET/POST /api/trading/conditions - 매수/매도 조건 설정
interface TradingConditions {
  buy_conditions: {
    amount: number;
    macd_type: "상향돌파" | "하향돌파" | "이상" | "이하";
    rsi_value: number;
    rsi_type: "상향돌파" | "하향돌파" | "이상" | "이하";
  };
  sell_conditions: {
    macd_type: "상향돌파" | "하향돌파" | "이상" | "이하";
    rsi_value: number;
    rsi_type: "상향돌파" | "하향돌파" | "이상" | "이하";
  };
}

// POST /api/trading/start - 자동매매 시작
// POST /api/trading/stop - 자동매매 중지
// GET /api/trading/status - 매매 상태 조회
```

#### **🔍 워치리스트 API**
```typescript
// GET /api/watchlist - 실시간 워치리스트
interface WatchlistItem {
  stock_code: string;
  current_price: number;
  profit_rate: number;
  avg_price: number;
  quantity: number;
  macd: number;
  macd_signal: number;
  rsi: number;
  trailing_stop_activated: boolean;
  trailing_stop_high: number;
}

// POST /api/watchlist/add - 종목 추가
// DELETE /api/watchlist/{stock_code} - 종목 제거
```

#### **📊 주문 관리 API**
```typescript
// POST /api/orders/buy - 매수 주문
// POST /api/orders/sell - 매도 주문
interface OrderRequest {
  stock_code: string;
  quantity: number;
  price: number;
  order_type: "00" | "01"; // 지정가/시장가
}

// GET /api/orders/history - 주문 내역
// GET /api/orders/pending - 미체결 주문
```

### **2. WebSocket 실시간 통신**

#### **실시간 데이터 스트림**
```typescript
// WebSocket 연결: ws://localhost:8000/ws
interface RealtimeMessage {
  type: "price_update" | "watchlist_update" | "account_update" | "order_update";
  timestamp: string;
  data: any;
}

// 가격 업데이트
interface PriceUpdate {
  type: "price_update";
  data: {
    stock_code: string;
    current_price: number;
    change: number;
    change_rate: number;
  };
}

// 워치리스트 업데이트 
interface WatchlistUpdate {
  type: "watchlist_update";
  data: WatchlistItem[];
}
```

## 🔧 백엔드 구현 계획

### **1. FastAPI 백엔드 서버**
```python
# main.py - FastAPI 서버
from fastapi import FastAPI, WebSocket
from fastapi.middleware.cors import CORSMiddleware
import asyncio
from typing import List
import json

app = FastAPI()

# CORS 설정 (Next.js 개발서버용)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 기존 KoreaInvestAPI 래퍼
korea_invest_api = None  # 전역 인스턴스

# WebSocket 연결 관리
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    async def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_text(json.dumps(message))

manager = ConnectionManager()
```

### **2. 데이터 동기화 서비스**
```python
# services/realtime_service.py
import asyncio
import pandas as pd
from datetime import datetime

class RealtimeDataService:
    def __init__(self, korea_invest_api, connection_manager):
        self.api = korea_invest_api
        self.manager = connection_manager
        self.watchlist_df = pd.DataFrame()
        self.is_running = False
    
    async def start_realtime_updates(self):
        """기존 타이머 로직을 async/await로 변환"""
        self.is_running = True
        
        # 병렬 실행: 계좌조회(2초), TR결과(0.05초), 등락률조회(2초)
        await asyncio.gather(
            self._account_update_loop(),    # 2초 주기
            self._tr_result_loop(),         # 0.05초 주기  
            self._market_data_loop(),       # 2초 주기
            self._settings_save_loop()      # 10초 주기
        )
    
    async def _account_update_loop(self):
        while self.is_running:
            try:
                # 기존 update_account_info() 로직
                account_data = self.api.get_acct_balance()
                await self.manager.broadcast({
                    "type": "account_update",
                    "data": account_data,
                    "timestamp": datetime.now().isoformat()
                })
            except Exception as e:
                logger.error(f"계좌 업데이트 오류: {e}")
            
            await asyncio.sleep(2)
```

## 🌐 프론트엔드 구현 계획

### **1. API 클라이언트 (Next.js)**
```typescript
// lib/api-client.ts
export class TradingAPIClient {
  private baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';
  private ws: WebSocket | null = null;
  
  // REST API 호출
  async getAccountBalance(): Promise<AccountBalance> {
    const response = await fetch(`${this.baseURL}/api/account/balance`);
    return response.json();
  }
  
  async getTradingConditions(): Promise<TradingConditions> {
    const response = await fetch(`${this.baseURL}/api/trading/conditions`);
    return response.json();
  }
  
  async updateTradingConditions(conditions: TradingConditions): Promise<void> {
    await fetch(`${this.baseURL}/api/trading/conditions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(conditions)
    });
  }
  
  // WebSocket 연결
  connectWebSocket(onMessage: (data: RealtimeMessage) => void): void {
    this.ws = new WebSocket(`ws://localhost:8000/ws`);
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onMessage(data);
    };
  }
}
```

### **2. React Hook 기반 상태 관리**
```typescript
// hooks/use-trading-data.ts
export function useTradingData() {
  const [accountBalance, setAccountBalance] = useState<AccountBalance | null>(null);
  const [watchlist, setWatchlist] = useState<WatchlistItem[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    const client = new TradingAPIClient();
    
    // 초기 데이터 로드
    client.getAccountBalance().then(setAccountBalance);
    client.getWatchlist().then(setWatchlist);
    
    // 실시간 연결
    client.connectWebSocket((message) => {
      switch (message.type) {
        case 'account_update':
          setAccountBalance(message.data);
          break;
        case 'watchlist_update':
          setWatchlist(message.data);
          break;
      }
    });
    
    setIsConnected(true);
  }, []);
  
  return { accountBalance, watchlist, isConnected };
}
```

## 🔐 보안 및 인증

### **1. API 인증**
- **JWT 토큰**: 기존 한국투자증권 토큰을 JWT로 래핑
- **CORS 설정**: Next.js 개발/프로덕션 도메인만 허용
- **Rate Limiting**: API 호출 횟수 제한

### **2. 환경 변수 관리**
```bash
# .env.local (Next.js)
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_WS_URL=ws://localhost:8000/ws

# .env (FastAPI)
KI_API_KEY=***
KI_SECRET_KEY=***
KI_ACCOUNT_NUMBER=***
CORS_ORIGINS=["http://localhost:3000", "https://yourdomain.com"]
```

## 📈 마이그레이션 전략

### **Phase 1: 백엔드 API 구축 (1주)**
1. FastAPI 서버 설정 및 기본 REST API 구현
2. 기존 KoreaInvestAPI 래퍼 클래스 통합
3. WebSocket 실시간 데이터 스트림 구현

### **Phase 2: 프론트엔드 연동 (1주)**  
1. Next.js API 클라이언트 구현
2. React Hook 기반 상태 관리 추가
3. 기존 정적 UI를 동적 데이터와 연결

### **Phase 3: 고도화 (1주)**
1. 에러 핸들링 및 재연결 로직
2. 성능 최적화 (메모리 사용량, 응답 속도)
3. 배포 환경 설정 (Docker, nginx)

### **Phase 4: 테스트 및 검증 (1주)**
1. 기존 PyQt5 버전과 기능/성능 비교
2. 모의 매매 환경에서 안정성 테스트
3. 사용자 인터페이스 UX 개선

## ⚡ 예상 이점

1. **접근성**: 웹 브라우저에서 어디서나 접근 가능
2. **확장성**: 모바일 앱, 다중 사용자 지원 용이
3. **유지보수**: 모던 웹 기술 스택으로 개발 생산성 향상
4. **모니터링**: 웹 기반 대시보드로 직관적인 데이터 시각화

## 🚀 구체적 구현 단계

### **Step 1: 디렉토리 구조 설정**
```
backend/                 # FastAPI 백엔드
├── app/
│   ├── main.py          # FastAPI 앱 진입점
│   ├── api/             # REST API 라우터
│   │   ├── account.py
│   │   ├── trading.py
│   │   └── watchlist.py
│   ├── models/          # Pydantic 모델
│   ├── services/        # 비즈니스 로직
│   └── websocket/       # WebSocket 핸들러
├── requirements.txt
└── Dockerfile

stock-trading-ui/        # Next.js 프론트엔드
├── src/
│   ├── app/             # App Router
│   ├── components/      # React 컴포넌트
│   ├── lib/             # 유틸리티
│   │   ├── api-client.ts
│   │   └── types.ts
│   └── hooks/           # Custom Hooks
├── package.json
└── Dockerfile
```

### **Step 2: 데이터 모델 정의**
```typescript
// lib/types.ts - 공통 타입 정의
export interface StockData {
  code: string;
  name: string;
  current_price: number;
  change: number;
  change_rate: number;
  volume: number;
}

export interface TechnicalIndicators {
  rsi: number;
  macd: number;
  macd_signal: number;
  macd_histogram: number;
}

export interface Position {
  stock_code: string;
  stock_name: string;
  quantity: number;
  avg_price: number;
  current_price: number;
  unrealized_pnl: number;
  profit_rate: number;
}
```

### **Step 3: API 라우터 구현**
```python
# app/api/account.py
from fastapi import APIRouter, Depends
from ..services.account_service import AccountService

router = APIRouter(prefix="/api/account")

@router.get("/balance")
async def get_account_balance(
    account_service: AccountService = Depends()
):
    return await account_service.get_balance()

@router.get("/positions")  
async def get_positions(
    account_service: AccountService = Depends()
):
    return await account_service.get_positions()
```

### **Step 4: WebSocket 연결 관리**
```python
# app/websocket/connection.py
from fastapi import WebSocket, WebSocketDisconnect
import asyncio
import json
from typing import List

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.realtime_task = None
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
        
        # 첫 번째 연결 시 실시간 데이터 스트림 시작
        if len(self.active_connections) == 1:
            self.realtime_task = asyncio.create_task(
                self.start_realtime_stream()
            )
    
    async def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
        
        # 마지막 연결 해제 시 실시간 스트림 중지
        if len(self.active_connections) == 0 and self.realtime_task:
            self.realtime_task.cancel()
    
    async def broadcast(self, data: dict):
        if self.active_connections:
            message = json.dumps(data)
            disconnected = []
            
            for connection in self.active_connections:
                try:
                    await connection.send_text(message)
                except:
                    disconnected.append(connection)
            
            # 끊어진 연결 정리
            for conn in disconnected:
                await self.disconnect(conn)
```

### **Step 5: React Hook 상태 관리**
```typescript
// hooks/use-realtime-data.ts
import { useState, useEffect, useCallback } from 'react';
import { TradingAPIClient } from '@/lib/api-client';

export function useRealtimeData() {
  const [accountBalance, setAccountBalance] = useState(null);
  const [watchlist, setWatchlist] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  
  const client = new TradingAPIClient();
  
  const handleRealtimeMessage = useCallback((message) => {
    switch (message.type) {
      case 'account_update':
        setAccountBalance(message.data);
        break;
      case 'watchlist_update':
        setWatchlist(message.data);
        break;
      case 'connection_status':
        setConnectionStatus(message.status);
        break;
    }
  }, []);
  
  useEffect(() => {
    // 초기 데이터 로드
    Promise.all([
      client.getAccountBalance(),
      client.getWatchlist()
    ]).then(([balance, watchlistData]) => {
      setAccountBalance(balance);
      setWatchlist(watchlistData);
    });
    
    // WebSocket 연결
    client.connectWebSocket(handleRealtimeMessage);
    
    return () => {
      client.disconnect();
    };
  }, [handleRealtimeMessage]);
  
  return {
    accountBalance,
    watchlist,
    connectionStatus,
    refreshData: () => {
      client.getAccountBalance().then(setAccountBalance);
      client.getWatchlist().then(setWatchlist);
    }
  };
}
```

## 📊 성능 고려사항

### **1. 백엔드 최적화**
- **비동기 처리**: asyncio 기반 논블로킹 I/O
- **커넥션 풀링**: 한국투자증권 API 연결 재사용
- **캐싱**: Redis를 이용한 빈번한 데이터 캐싱
- **배치 처리**: 여러 종목 데이터를 한 번에 처리

### **2. 프론트엔드 최적화**
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo/useCallback**: 복잡한 계산 메모이제이션
- **Virtual Scrolling**: 대량 데이터 테이블 성능 향상
- **Debouncing**: 사용자 입력 처리 최적화

### **3. 네트워크 최적화**
- **WebSocket 재연결**: 자동 재연결 로직
- **데이터 압축**: JSON 데이터 압축 전송
- **Delta Updates**: 변경된 데이터만 전송
- **Heartbeat**: 연결 상태 모니터링